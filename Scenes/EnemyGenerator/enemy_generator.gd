extends Node
class_name EnemyGenerator

signal state_changed(new_state:State)
## An enemy has been generated
signal generated(what)
## The next have has started
signal wave_started
## The wait period to start the next wave has started
signal wave_wait_started
## All the enemies in this wave have been generated
signal wave_finished
## All the enemies generated so far have died
signal all_dead
## All waves generated and finished
signal finished
## Stopped for any reason
signal stopped


enum State {
	_undef,
	## Doing nothing, awaiting external input
	STOPPED,
	## Waiting for the timer to run out so we can generate a new enemy
	NEXT_ENEMY_WAITING,
	## All enemies of the current wave have been generated, waiting for them to die
	WAITING_FOR_WAVE_END,
	## Wave could start, but is waiting for an external trigger
	WAITING_FOR_MANUAL_START,
	## All enemies of the current wave have died, waiting for the next wave to start
	NEXT_WAVE_WAITING,
	## No waves left, waiting for the last wave's enemies to die
	## TODO: merge with NEXT_WAVE_WAITING, and check is_last_wave when a wave finishes
	WAITING_FOR_LAST_WAVE_END,
}

enum WaveStartModes {
	## Star the wave timer when all enemies of the previous wave have died
	WHEN_ALL_DEAD,
	## Start the next wave timer right after the last enemy is generated
	IMMEDIATELY,
	## Method start_next_wave must be called manually
	MANUALLY,
}


var state:State = State._undef : set = set_state
## Seconds until the next enemy should be generated
var time_to_next_enemy:float = NAN
## Seconds until the next wave should start
var time_to_next_wave:float = NAN

## Number of the wave currently generating enemies
var current_wave:int = -1
## How many enemies have been generated so far in the current wave
var generated_so_far:int = 0
## Enemies generated by this that are currently alive
var currently_alive:Array[Actor] = []

## Time between one enemy is generated and the next
@export var time_between_enemies:float = 1
## Seconds before the next wave starts, counted after the previous wave
## generates its last enemy or after all enemies are dead, depending on
## the configuration
@export var time_between_waves:float = 5
## What should trigger the start of the next wave
@export var wave_start_mode:WaveStartModes = WaveStartModes.WHEN_ALL_DEAD
## EnemyModel to be used to generate enemies. Will get more complex.
@export var enemy_model:ActorModel
## Number of enemies in each of the waves. Provisional, will get more complex.
@export var sequences:Array[int] = []
@export_group("Debug")
@export var verbose:bool = false


func _ready()-> void:
	state = State.STOPPED
	reset()
	
	
func p(msg:String = "")-> void:
	if verbose:
		print(msg)
		
	
func set_state(new_value:State)-> void:
	var old_value = state
	var has_changed:bool = new_value != old_value
	state = new_value
	
	if has_changed:
		state_changed.emit(state)
		p("State changed to %s" % State.keys()[state])
	
	
# Get a 1-based index for the wave currently generating enemies
func get_current_wave_number()-> int:
	if current_wave < 0:
		return -1
	return current_wave + 1
	
	
func get_number_of_waves()-> int:
	return len(sequences)
	
	
## Has the current wave generated all enemies?
func is_wave_done()-> bool:
	assert(current_wave >= 0)
	assert(current_wave < len(sequences))
	return generated_so_far >= sequences[current_wave]


func is_waiting_for_manual_start()-> bool:
	return state == State.WAITING_FOR_MANUAL_START
	

## Is the current wave the last one?
func is_last_wave()-> bool:
	return current_wave == get_number_of_waves()-1
	

## Completely resets the generator. Should not be used between waves
func reset()-> void:
	current_wave = -1
	generated_so_far = 0
	currently_alive = []
	time_to_next_wave = NAN
	time_to_next_enemy = NAN
		
		
## Makes the next scheduled wave start generating enemies
func start()-> void:
	assert(is_stopped())
	reset()
	p("Wave generation starting")
	if wave_start_mode == WaveStartModes.MANUALLY:
		state = State.WAITING_FOR_MANUAL_START
	else:
		start_next_wave()
	
	
## Stops generating enemies and resets everything
func stop()-> void:
	reset()
	state = State.STOPPED
	p("Wave generation finished")
	stopped.emit()
	
	
## Whether the generator is doing anything at all
func is_stopped()-> bool:
	return state == State.STOPPED
	
	
## Whether any wave has started
func has_started()-> bool:
	if is_stopped(): return false
	# If we are not in the stopped state but the current_wave indicator is still negative...
	if current_wave < 0: return false
	
	# Otherwise at least the first wave has started
	return true
	

## Make the next wave start generating enemies
func start_next_wave()-> void:
	assert(not is_last_wave())
	if not (is_zero_approx(time_to_next_wave) or is_nan(time_to_next_wave)):
		if not wave_start_mode == WaveStartModes.MANUALLY:
			var m = "start_next_wave called while time_to_next_wave was not zero"
			push_warning(m)
		
	state = State.NEXT_ENEMY_WAITING
	generated_so_far = 0
	time_to_next_enemy = NAN
	current_wave += 1
	
	p("Starting wave %s" % current_wave)
	wave_started.emit()
	generate()
	
	
## Called when the wave has generated its last enemy
func _on_wave_finished()-> void:
	wave_finished.emit()
	p("Wave %s finished (generated its last enemy)" % current_wave)
	
	if is_last_wave():
		p("\t(was last wave, waiting for it to end, i.e. all enemies to die)")
		state = State.WAITING_FOR_LAST_WAVE_END
	else:
		match wave_start_mode:
			WaveStartModes.IMMEDIATELY:
				p("Starting timer for next wave immediately")
				start_wait_for_next_wave()
			WaveStartModes.WHEN_ALL_DEAD, WaveStartModes.MANUALLY:
				p("Waiting for enemies to die before starting wait for next wave")
				state = State.WAITING_FOR_WAVE_END
		
		
## Start counting time before starting the next wave
func start_wait_for_next_wave()-> void:	
	p("Starting timer for next wave")
	state = State.NEXT_WAVE_WAITING
	time_to_next_wave = time_between_waves
	p("\t(next wave timer reset to %2.2f)" % time_to_next_wave)
	wave_wait_started.emit()
	
	
## Generate the next enemy in the sequence
func generate()-> void:
	var new_enemy:BaseActor = enemy_model.make_one()
	generated.emit(new_enemy)
	generated_so_far += 1
	currently_alive.append(new_enemy)
	new_enemy.destruction_started.connect(_on_enemy_started_dying.bind(new_enemy))
	p("Enemy generated (%s)" % new_enemy)
		 
	if is_wave_done():
		p("\t(enemy %s was the last one)" % new_enemy)
		_on_wave_finished()
	else:
		time_to_next_enemy = time_between_enemies
		p("\t(enemy generation timer reset to %2.2f)" % time_to_next_enemy)
		
		
## Called when a generated enemy starts performing its death process
func _on_enemy_started_dying(enemy:BaseActor)-> void:
	if state == State.STOPPED:
		return
		
	if enemy in currently_alive:
		currently_alive.erase(enemy)
	else:
		push_warning("Enemy %s started dying but was already out of currently_alive" % enemy)
	if currently_alive.is_empty():
		_on_all_enemies_dead()
	
	
## Called when all enemies generated so far have died
func _on_all_enemies_dead()-> void:
	all_dead.emit()
	p("All enemies are dead")
	
	match state:		
		# If we were waiting for the current wave to finish, trigger the next wave
		State.WAITING_FOR_WAVE_END:
			match wave_start_mode:
				WaveStartModes.WHEN_ALL_DEAD:					
					#p("\t(was waiting for all enemies to die to start the next wave wait time)")
					start_wait_for_next_wave()
				WaveStartModes.MANUALLY:
					state = State.WAITING_FOR_MANUAL_START
		# If we were waiting for the last one to finish, stop the generation
		State.WAITING_FOR_LAST_WAVE_END:
			p("\t(was waiting for all enemies to die to finish)")
			stop()
			finished.emit()
			
		_:
			p("\n(no reaction to death of enemies)")
	
	
func _physics_process(delta: float) -> void:
	match state:
		State.NEXT_ENEMY_WAITING:
			time_to_next_enemy -= delta
			if time_to_next_enemy <= 0:
				time_to_next_enemy = 0
				p("Time to next enemy finished")
				generate()
		State.NEXT_WAVE_WAITING:
			time_to_next_wave -= delta
			if time_to_next_wave <= 0.0:
				time_to_next_wave = 0
				p("Time to next wave finished")
				start_next_wave()
